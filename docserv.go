package docserv

import (
	"fmt"
	"html/template"
	"io/ioutil"
	"net/http"

	"github.com/russross/blackfriday"
)

const TEMPLATE = "docs"

var (
	parsedTemplate *template.Template
	defaultConfig  = &DocServConfig{
		Endpoint:        "/docs",
		UseStatic:       false,
		Host:            "",
		Port:            "9000",
		UseHighlighting: true,
		SyntaxStyle:     "darkula",
	}
)

type DocServConfig struct {
	Endpoint        string            // Endpoint to listen to (default: /docs)
	UseStatic       bool              // Whether to use Static mode (default: false)
	Docs            map[string][]byte // The filepaths for documentation
	Host            string            // The host part of the HTTP listener (default: "")
	Port            string            // The port part of the HTTP listener (default: 9000)
	UseHighlighting bool              // Whether to use syntax highlighting (default: true)
	SyntaxStyle     string            // The style to use for syntax highlighting (default: darkula)
}

type DocServ struct {
	DocServConfig DocServConfig
	docFiles      map[string]template.HTML
}

// NewDocServ will generate a DocServ instance
// and requires a list of documents
func NewDocServ(docs []string) *DocServ {

	docMap := make(map[string][]byte)
	for _, doc := range docs {
		docMap[doc] = []byte{}
	}

	cfg := defaultConfig
	cfg.Docs = docMap

	d := DocServ{
		DocServConfig: *cfg,
		docFiles:      map[string]template.HTML{},
	}
	return &d
}

// NewStaticDocServ will generate a DocServ instance
// and requires a list of documents, it will look for
// static assets generated by ./static.sh
func NewStaticDocServ(docs map[string][]byte) *DocServ {
	cfg := defaultConfig
	cfg.Docs = docs
	cfg.UseStatic = true

	d := DocServ{
		DocServConfig: *cfg,
		docFiles:      map[string]template.HTML{},
	}
	return &d
}

// Run will start up the DocServ process, get the template,
// change the documents to markdown and serve them over HTTP
func (d *DocServ) Run() (err error) {
	// get template
	if err = parseTemplate(); err != nil {
		return err
	}

	// validate docs
	err = d.convertFiles()
	if err != nil {
		return err
	}

	// serve docs
	fmt.Printf("Serving your docs at %s%s", d.getAddress(), d.DocServConfig.Endpoint)

	http.HandleFunc(d.DocServConfig.Endpoint, d.Handler)
	return http.ListenAndServe(d.getAddress(), nil)
}

func (d *DocServ) convertFiles() (err error) {
	for doc, c := range d.DocServConfig.Docs {
		if !d.DocServConfig.UseStatic {
			c, err = ioutil.ReadFile(doc)
			if err != nil {
				return fmt.Errorf("Failed to read file: %v", err)
			}
		}
		md := blackfriday.MarkdownCommon(c)
		d.docFiles[doc] = template.HTML(md)
	}
	return nil
}

// Handler is the default handler for all DocServ HTTP requests
func (d *DocServ) Handler(w http.ResponseWriter, r *http.Request) {
	err := parsedTemplate.ExecuteTemplate(w, TEMPLATE, d)
	if err != nil {
		fmt.Fprintf(w, "Failed to execute template: %v", err)
	}
}

func (d *DocServ) getAddress() string {
	return fmt.Sprintf("%s:%s", d.DocServConfig.Host, d.DocServConfig.Port)
}

// DocFiles is a public method for use in the template
func (d *DocServ) DocFiles() map[string]template.HTML {
	return d.docFiles
}
