package docserv

import (
	"fmt"
	"github.com/gerbenjacobs/docserv/static"
	"github.com/russross/blackfriday"
	"html/template"
	"io/ioutil"
	"net/http"
	"regexp"
)

const TEMPLATE = "docs"

var (
	//defaultConfig   *DocServConfig
	parsedTemplate  *template.Template
	identifierRegex = regexp.MustCompile("[^A-Za-z0-9]+")
	defaultConfig   = &DocServConfig{
		Endpoint:        "/docs",
		UseStatic:       false,
		Host:            "",
		Port:            "9000",
		UseHighlighting: true,
		SyntaxStyle:     "darkula",
	}
)

type DocServConfig struct {
	Endpoint        string   // Endpoint to listen to (default: /docs)
	UseStatic       bool     // Whether to use Static mode (default: false)
	Docs            []string // The filepaths for documentation
	Host            string   // The host part of the HTTP listener (default: "")
	Port            string   // The port part of the HTTP listener (default: 9000)
	UseHighlighting bool     // Whether to use syntax highlighting (default: true)
	SyntaxStyle     string   // The style to use for syntax highlighting (default: darkula)
}

type DocServ struct {
	DocServConfig DocServConfig
	docFiles      map[string]template.HTML
}

//func init() {
//	defaultConfig = &DocServConfig{
//		Endpoint:        "/docs",
//		UseStatic:       false,
//		Host:            "",
//		Port:            "9000",
//		UseHighlighting: true,
//		SyntaxStyle:     "darkula",
//	}
//}

// NewDocServ will generate a DocServ instance
// and requires a list of documents
func NewDocServ(docs []string) *DocServ {
	cfg := defaultConfig
	cfg.Docs = docs

	d := DocServ{
		DocServConfig: *cfg,
		docFiles:      map[string]template.HTML{},
	}
	return &d
}

// NewStaticDocServ will generate a DocServ instance
// and requires a list of documents, it will look for
// static assets generated by ./static.sh
func NewStaticDocServ(docs []string) *DocServ {
	cfg := defaultConfig
	cfg.Docs = docs
	cfg.UseStatic = true

	d := DocServ{
		DocServConfig: *cfg,
		docFiles:      map[string]template.HTML{},
	}
	return &d
}

// Run will start up the DocServ process, get the template,
// change the documents to markdown and serve them over HTTP
func (d *DocServ) Run() (err error) {
	// get template
	if err = parseTemplate(); err != nil {
		return err
	}

	// validate docs
	err = d.convertFiles(d.DocServConfig.UseStatic)
	if err != nil {
		return err
	}

	// serve docs
	fmt.Printf("Serving your docs at %s%s", d.getAddress(), d.DocServConfig.Endpoint)

	http.HandleFunc(d.DocServConfig.Endpoint, d.Handler)
	return http.ListenAndServe(d.getAddress(), nil)
}

func (d *DocServ) convertFiles(useStatic bool) (err error) {
	for _, doc := range d.DocServConfig.Docs {
		var c []byte
		if useStatic {
			c, err = static.Asset(doc)
			if err != nil {
				return fmt.Errorf("Failed to read asset: %v", err)
			}
		} else {
			c, err = ioutil.ReadFile(doc)
			if err != nil {
				return fmt.Errorf("Failed to read file: %v", err)
			}
		}
		md := blackfriday.MarkdownCommon(c)
		d.docFiles[doc] = template.HTML(md)
	}
	return nil
}

// Handler is the default handler for all DocServ HTTP requests
func (d *DocServ) Handler(w http.ResponseWriter, r *http.Request) {
	err := parsedTemplate.ExecuteTemplate(w, TEMPLATE, d)
	if err != nil {
		fmt.Fprintf(w, "Failed to execute template: %v", err)
	}
}

func (d *DocServ) getAddress() string {
	return fmt.Sprintf("%s:%s", d.DocServConfig.Host, d.DocServConfig.Port)
}

// DocFiles is a public method for use in the template
func (d *DocServ) DocFiles() map[string]template.HTML {
	return d.docFiles
}
